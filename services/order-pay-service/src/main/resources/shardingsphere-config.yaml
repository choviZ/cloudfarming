# 数据源集合，也就是咱们刚才说的分两个库
dataSources:
  ds_0:
    dataSourceClassName: com.zaxxer.hikari.HikariDataSource
    driverClassName: com.mysql.cj.jdbc.Driver
    jdbcUrl: jdbc:mysql://127.0.0.1:3306/cloud_farming?useUnicode=true&characterEncoding=UTF-8&rewriteBatchedStatements=true&allowMultiQueries=true&serverTimezone=Asia/Shanghai&autoReconnect=true&failOverReadOnly=false&maxReconnects=10
    username: root
    password: root
    # HikariCP 连接池配置
    connectionTimeout: 30000
    idleTimeout: 600000
    maxLifetime: 1800000
    maximumPoolSize: 20
    minimumIdle: 5
    connectionTestQuery: SELECT 1
    validationTimeout: 5000

rules:
  # 分片规则
  - !SHARDING
  # 分片表
    tables:
      # 订单表
      t_order:
        # 真实的数据节点，也对应着在数据库中存储的真实表
        actualDataNodes: ds_0.t_order_${0..7}
        # 分表策略
        tableStrategy:
          # 复合分表策略（多个分片键）
          complex:
            # 用户 ID 和订单号
            shardingColumns: user_id,order_no
            # 搜索 order_table_complex_mod 下方会有分表算法
            shardingAlgorithmName: order_table_complex_mod
      # 订单明细表，规则同订单表
      t_order_item:
        actualDataNodes: ds_0.t_order_detail_sku${0..7}
        tableStrategy:
          complex:
            shardingColumns: order_no
            shardingAlgorithmName: order_detail_table_complex_mod
    # 分片算法
    shardingAlgorithms:
      # 订单分表算法
      order_table_complex_mod:
        # 通过加载全限定名类实现分片算法，相当于分片逻辑都在 algorithmClassName 对应的类中
        type: CLASS_BASED
        props:
          algorithmClassName: com.vv.cloudfarming.order.dao.algorithm.OrderTableComplexAlgorithm
          # 分表数量
          sharding-count: 8
          # 复合（多分片键）分表策略
          strategy: complex
      order_detail_table_complex_mod:
        type: CLASS_BASED
        props:
          algorithmClassName: com.vv.cloudfarming.order.dao.algorithm.OrderTableComplexAlgorithm
          sharding-count: 8
          strategy: complex
props:
  sql-show: true